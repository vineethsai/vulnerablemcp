<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Complete guide to ETDI: Enhanced Tool Definition Interface for securing Model Context Protocol against tool poisoning and rug pull attacks">
    <meta name="keywords" content="ETDI, MCP security, Enhanced Tool Definition Interface, tool poisoning prevention, rug pull prevention, OAuth 2.0, policy-based access control, Cedar, OPA, AI security">
    <meta name="author" content="ETDI Security Framework">
    <meta property="og:title" content="ETDI: Comprehensive MCP Security Framework">
    <meta property="og:description" content="Complete security framework for protecting Large Language Model applications from critical vulnerabilities using Enhanced Tool Definition Interface">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://vulnerablemcp.info/enhanced-etdi-security.html">
    <meta property="og:site_name" content="The Vulnerable MCP Project">
    <meta property="og:image" content="https://vulnerablemcp.info/favicon.svg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ETDI: Comprehensive MCP Security Framework">
    <meta name="twitter:description" content="Complete security framework for protecting Large Language Model applications from critical vulnerabilities">
    <meta name="twitter:image" content="https://vulnerablemcp.info/favicon.svg">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.svg">
    <link rel="canonical" href="https://vulnerablemcp.info/enhanced-etdi-security.html">
    <title>ETDI: Enhanced Tool Definition Interface | MCP Security Framework</title>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WQZ3K6M59C"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-WQZ3K6M59C');
    </script>
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TechArticle",
      "headline": "ETDI: Enhanced Tool Definition Interface for MCP Security",
      "description": "Complete security framework for protecting Large Language Model applications from tool poisoning and rug pull attacks",
      "author": {
        "@type": "Organization",
        "name": "ETDI Security Framework"
      },
      "publisher": {
        "@type": "Organization",
        "name": "The Vulnerable MCP Project",
        "url": "https://vulnerablemcp.info/"
      },
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://vulnerablemcp.info/enhanced-etdi-security.html"
      },
      "keywords": ["ETDI", "MCP security", "OAuth 2.0", "policy-based access control", "tool poisoning", "rug pull attacks"]
    }
    </script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <style>
        .security-main {
            flex: 1;
            padding: 0 2rem;
            max-width: none !important;
            width: 100%;
        }

        .image-container {
            text-align: center;
            margin: 3rem 0;
        }

        .image-container img {
            max-width: 100%;
            min-width: 700px;
            width: 90%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        .image-container img:hover {
            transform: scale(1.03);
            box-shadow: 0 12px 48px rgba(0,0,0,0.2);
        }

        .section {
            margin-bottom: 3rem;
            background: white;
        }

        /* Mobile responsive for images */
        @media (max-width: 768px) {
            .image-container img {
                min-width: 100%;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <h1><a href="index.html">The Vulnerable MCP Project</a></h1>
            </div>
            <nav>
                <button class="nav-toggle" aria-label="toggle navigation" aria-expanded="false">
                    <span class="hamburger">&#9776;</span>
                </button>
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
                    <li><a href="https://roqwvequ.genspark.space/" target="_blank">Enterprise Security</a></li>
                    <li><a href="https://github.com/vineethsai/vulnerablemcp" target="_blank">Contribute</a></li>
                    <li><a href="security.html">Understanding MCP Security</a></li>
                    <li><a href="etdi-security.html" class="active">ETDI Security</a></li>
                    <li><a href="https://vineethsai.com" target="_blank">Author</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="security-header">
            <div class="research-badge">Security Framework</div>
            <h1>ETDI: Enhanced Tool Definition Interface</h1>
            <p class="subtitle">Comprehensive MCP Security Framework</p>
            <p>A robust security framework for protecting Large Language Model applications from tool poisoning and rug pull attacks through cryptographic verification, OAuth integration, and policy-based access control.</p>
        </div>

        <div class="security-content">
            <nav class="security-nav">
                <h3>Navigation</h3>
                <ul>
                    <li><a href="#overview">Overview</a></li>
                    <li><a href="#mcp-architecture">Model Context Protocol Architecture</a></li>
                    <li><a href="#vulnerabilities">Critical Security Vulnerabilities</a></li>
                    <li><a href="#tool-poisoning">Tool Poisoning Attacks</a></li>
                    <li><a href="#rug-pull">Rug Pull Attacks</a></li>
                    <li><a href="#etdi-framework">ETDI Framework</a></li>
                    <li><a href="#cryptographic-identity">Cryptographic Identity Verification</a></li>
                    <li><a href="#immutable-definitions">Immutable and Versioned Definitions</a></li>
                    <li><a href="#oauth-enhancement">OAuth 2.0 Enhancement</a></li>
                    <li><a href="#policy-based-control">Policy-Based Access Control</a></li>
                    <li><a href="#cedar-integration">Cedar Policy Language Integration</a></li>
                    <li><a href="#call-stack-verification">Call Stack Verification</a></li>
                    <li><a href="#security-analysis">Comprehensive Security Analysis</a></li>
                    <li><a href="#implementation">Implementation Guide</a></li>
                    <li><a href="#best-practices">Best Practices and Recommendations</a></li>
                </ul>
            </nav>

            <main class="security-main">
                <section id="overview" class="section">
                    <h2>Framework Overview</h2>
                    <p>The Model Context Protocol (MCP) enables Large Language Models (LLMs) to integrate with external tools and data sources, but the standard specification presents significant security vulnerabilities, notably <strong>Tool Poisoning</strong> and <strong>Rug Pull attacks</strong>.</p>
                    <p>The <strong>Enhanced Tool Definition Interface (ETDI)</strong> is a comprehensive security extension for MCP, designed to address these critical threats and establish a new standard for trust, integrity, and control in LLM tool ecosystems.</p>
                    <ul>
                        <li><strong>Cryptographic Identity & Integrity:</strong> Every tool definition is digitally signed by its provider, and signatures are verified by clients, ensuring authenticity and preventing impersonation or tampering.</li>
                        <li><strong>Immutable, Versioned Tool Definitions:</strong> Any change to a tool's code, schema, or permissions requires a new version and explicit user re-approval, blocking silent or malicious modifications after initial approval.</li>
                        <li><strong>Explicit Permission Management:</strong> Tools must declare all required capabilities and permissions up front, with fine-grained OAuth 2.0 scopes and user consent for every sensitive action.</li>
                        <li><strong>Policy-Based Access Control:</strong> Dynamic, context-aware authorization using Cedar policies and Amazon Verified Permissions, enabling real-time risk assessment and adaptive security.</li>
                        <li><strong>Comprehensive Auditability:</strong> All tool approvals, version changes, and policy decisions are logged for full traceability and compliance.</li>
                    </ul>
                    <div class="note">
                        <strong>How ETDI Stops Tool Poisoning & Rug Pulls — In a Nutshell:</strong><br>
                        <ul>
                            <li><strong>Tool Poisoning:</strong> ETDI's cryptographic signatures and provider verification make it nearly impossible for attackers to impersonate or spoof trusted tools. Only tools with valid, verifiable signatures from known providers are accepted.</li>
                            <li><strong>Rug Pull Attacks:</strong> ETDI enforces immutability and versioning. Any change to a tool's definition, code, or permissions requires a new version and explicit user re-approval, so users are never silently exposed to new risks.</li>
                        </ul>
                        <strong>Bottom line:</strong> <em>ETDI transforms MCP from a trust-based model to a verifiable, policy-driven security framework—eliminating the root causes of tool poisoning and rug pull attacks.</em>
                    </div>
                </section>

                <section id="mcp-architecture" class="section">
                    <h2>Model Context Protocol Architecture</h2>
                    <p>MCP operates on a distributed client-server model with the following key components:</p>
                    
                    <h3>Core Components</h3>
                    <ul>
                        <li><strong>Host Applications:</strong> User-facing applications (AI-powered desktop apps, IDE extensions) that orchestrate interactions</li>
                        <li><strong>MCP Clients:</strong> Software components within Host Applications that discover, connect to, and interact with MCP Servers</li>
                        <li><strong>MCP Servers:</strong> Services that expose capabilities (tools, resources, prompts) to MCP Clients</li>
                        <li><strong>Tools:</strong> Discrete functions or services invokable by an LLM via an MCP Server</li>
                        <li><strong>Resources:</strong> Data sources accessible by the LLM for context</li>
                        <li><strong>Prompts:</strong> Pre-defined templates guiding LLM tool/resource usage</li>
                    </ul>

                    <div class="architecture-diagram">
                        <p>🏗️ Standard MCP Architecture Flow</p>
                        <p>User ↔ Host Application ↔ MCP Client ↔ LLM ↔ MCP Server ↔ Tools</p>
                    </div>
                    <div class="image-container">
                        <img src="high-level-arch.png" alt="High-level MCP architecture diagram">
                    </div>

                    <h3>Operational Phases</h3>
                    <h4>1. Initialization and Discovery Phase</h4>
                    <ol>
                        <li><strong>Application Launch & Client Initialization:</strong> Host Application initializes embedded MCP Client modules</li>
                        <li><strong>Server Handshake and Capability Negotiation:</strong> MCP Clients initiate handshake with discoverable MCP Servers</li>
                        <li><strong>Tool Listing Request:</strong> Client sends listTools request to enumerate available tools</li>
                        <li><strong>Tool Definition Exchange:</strong> Servers respond with tool definitions including descriptions, schemas, and parameters</li>
                    </ol>

                    <div class="image-container">
                        <img src="Initialization-and-Discovery-Phase.png" alt="Initialization and Discovery Phase Diagram">
                    </div>

                    <h4>2. Tool Invocation and Usage Phase</h4>
                    <ol>
                        <li><strong>User Request Processing:</strong> User interacts with Host Application requiring external tool capabilities</li>
                        <li><strong>Tool Selection by LLM:</strong> LLM processes request and identifies suitable tools based on descriptions</li>
                        <li><strong>Permission Adjudication:</strong> Client prompts user for approval if tool requires specific permissions</li>
                        <li><strong>Tool Invocation Command:</strong> Client dispatches invokeTool command with specified parameters</li>
                        <li><strong>Server-Side Tool Execution:</strong> MCP Server delegates request to actual tool implementation</li>
                        <li><strong>Result Propagation:</strong> Tool returns output to server, which relays to client</li>
                        <li><strong>Context Augmentation:</strong> Results are incorporated into LLM context for final response generation</li>
                    </ol>

                    <div class="image-container">
                        <img src="Tool-Invocation-and-Usage-Phase.png" alt="Tool Invocation and Usage Phase Diagram">
                    </div>

                    <div class="warning">
                        <strong>Critical Gap:</strong> Standard MCP lacks verifiable authenticity or integrity markers in tool definitions, creating significant security vulnerabilities.
                    </div>
                </section>

                <section id="vulnerabilities" class="section">
                    <h2>Critical Security Vulnerabilities in MCP</h2>
                    <p>The standard MCP specification, while fostering innovation, lacks comprehensive security primitives exposing users and systems to significant risks through two primary attack vectors:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🎭 Tool Poisoning</h4>
                            <p>Malicious actors deploy tools that masquerade as legitimate, trusted tools to deceive users and LLMs into granting unauthorized access.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🪝 Rug Pull Attacks</h4>
                            <p>Post-approval modification of tool functionality without user notification, effectively bypassing initial permission models.</p>
                        </div>
                    </div>
                </section>

                <section id="tool-poisoning" class="section">
                    <h2>Tool Poisoning Attacks</h2>
                    <p><strong>Definition:</strong> Tool Poisoning involves a malicious actor deploying a tool that masquerades as a legitimate, trusted, or innocuous tool. The attacker's objective is to deceive either the end-user or the LLM during automated tool selection.</p>

                    <h3>Vulnerability Analysis</h3>
                    <p>The susceptibility to Tool Poisoning in standard MCP stems from several critical deficiencies:</p>
                    
                    <ul>
                        <li><strong>Lack of Authenticity Verification:</strong> No built-in mechanism for MCP Clients or users to cryptographically verify the true origin or authenticity of a tool. Tool names, descriptions, and provider names can be easily spoofed.</li>
                        <li><strong>Indistinguishable Duplicates and Ambiguity:</strong> Malicious tools can meticulously replicate metadata of legitimate tools, making differentiation virtually impossible for users or automated LLM-based selection processes.</li>
                        <li><strong>Exploitation of Implicit Trust:</strong> Attackers leverage user trust in familiar tool names or reputable provider names without any underlying validation mechanism.</li>
                        <li><strong>Unverifiable Claims in Descriptions:</strong> Tools can assert claims like "secure," "official," or "privacy-preserving" without any mechanism to validate these assertions.</li>
                    </ul>

                    <h3>Attack Impact</h3>
                    <p>Successful tool poisoning can lead to severe consequences including:</p>
                    <ul>
                        <li>Exfiltration of sensitive personal or corporate data</li>
                        <li>Unauthorized execution of system commands</li>
                        <li>Installation of malware or ransomware</li>
                        <li>Financial fraud through manipulated transactions</li>
                        <li>Subtle manipulation of LLM outputs to spread misinformation</li>
                    </ul>

                    <div class="code-block" data-language="Attack Scenario">
<pre>
Illustrative Scenario: Malicious "SecureDocs Scanner"

1. Attacker deploys malicious MCP server hosting "SecureDocs Scanner"
2. Meticulously copies description, JSON schema, and claims "TrustedSoft Inc." as provider
3. User's MCP Client discovers both legitimate and malicious versions
4. Due to identical presentation, tools appear as duplicates
5. User selects entry corresponding to malicious version
6. Upon invocation, malicious tool:
   - Exfiltrates entire document content to attacker-controlled server
   - Returns fake "No PII found" message to maintain deception
</pre>
                    </div>

                    <div class="architecture-diagram">
                        <p>⚠️ Tool Poisoning Attack Flow</p>
                        <p>Legitimate Tool ← Impersonated by → Malicious Tool → Data Exfiltration</p>
                    </div>
                    <div class="image-container">
                        <img src="tool-poisoning.png" alt="Tool Poisoning Attack Diagram">
                    </div>
                </section>

                <section id="rug-pull" class="section">
                    <h2>Rug Pull Attacks</h2>
                    <p><strong>Definition:</strong> Rug Pull attacks manifest when the functionality, data access patterns, or permission requirements of an already approved tool are maliciously altered by its provider after initial user consent has been granted.</p>

                    <h3>Vulnerability Analysis</h3>
                    <p>The core vulnerabilities enabling Rug Pulls include:</p>
                    
                    <ul>
                        <li><strong>Mutability of Server-Side Logic:</strong> Tool's underlying code and behavior can be modified without notification to MCP Client or user, especially if the tool's primary identifier remains static.</li>
                        <li><strong>Lack of Continuous Integrity Checks:</strong> Standard MCP Clients don't re-fetch and re-verify tool definitions on subsequent invocations once approved.</li>
                        <li><strong>Absence of Re-Approval Triggers:</strong> No new approval prompt is presented if the tool's identifier doesn't change, even if functionality is modified.</li>
                        <li><strong>Exploitation of Established Trust:</strong> Attack leverages trust established during initial benign approval phase.</li>
                    </ul>

                    <h3>Attack Impact</h3>
                    <p>Rug Pulls can lead to severe breaches including:</p>
                    <ul>
                        <li>Unauthorized access to sensitive data never explicitly consented to</li>
                        <li>Bypass of initial permission model</li>
                        <li>Profound loss of user trust once discovered</li>
                        <li>Silent background data collection and transmission</li>
                    </ul>

                    <div class="code-block" data-language="Attack Scenario">
<pre>
Illustrative Scenario: "Daily Wallpaper" Tool Rug Pull

Initial State (Version 1.0):
- Fetches new wallpaper image and sets it
- Requests permission for "access internet" and "modify desktop wallpaper"
- User approves based on benign functionality

Post-Approval Modification:
- Tool still identified as "Daily Wallpaper v1.0" to avoid re-approval
- Server-side logic updated to:
  • Scan user's Documents folder for financial keywords
  • Upload found files to attacker-controlled server
  • Continue wallpaper functionality to maintain deception

Result: Malicious action performed silently without user awareness
</pre>
                    </div>

                    <div class="architecture-diagram">
                        <p>🪝 Rug Pull Attack Flow</p>
                        <p>Benign Tool (Initial Approval) → Silent Modification → Malicious Behavior (No Re-approval)</p>
                    </div>
                    <div class="image-container">
                        <img src="rug-pull.png" alt="Rug Pull Attack Diagram">
                    </div>
                </section>

                <section id="etdi-framework" class="section">
                    <h2>ETDI: The Enhanced Tool Definition Interface</h2>
                    <p>ETDI is a comprehensive security layer extension for MCP designed to counter Tool Poisoning and Rug Pulls by introducing verifiable identity and integrity for tool definitions.</p>

                    <h3>Foundational Security Principles</h3>
                    <p>ETDI is architected upon three fundamental security principles:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🔐 Cryptographic Identity and Authenticity</h4>
                            <p>Tool definitions are digitally signed by providers. MCP Clients verify these signatures using established cryptographic protocols.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📋 Immutable and Versioned Definitions</h4>
                            <p>Any change to tool functionality, metadata, schema, permissions, or backend API contract mandates a new, signed version with user re-approval.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🎛️ Explicit and Verifiable Permissions</h4>
                            <p>Tool's required capabilities (OAuth scopes) are declared in signed definition and presented to users for explicit approval.</p>
                        </div>
                    </div>

                    <div class="code-block" data-language="JavaScript">
<pre>
// Simplified ETDI Tool Definition Verification Logic
function verifyAndApproveTool(toolDefinition, providerPublicKey) {
    // 1. Verify cryptographic identity and integrity
    if (!Crypto.verifySignature(
        toolDefinition.content,
        toolDefinition.signature, 
        providerPublicKey
    )) {
        log("Tool definition signature invalid for " + toolDefinition.id);
        return false; // Reject tool
    }

    // 2. Check against previously approved version (if any)
    const approvedDef = getApprovedDefinition(toolDefinition.id);
    if (approvedDef != null) {
        if (toolDefinition.version == approvedDef.version) {
            // If version same, ensure definition content hash matches
            if (Crypto.hash(toolDefinition.content) != approvedDef.contentHash) {
                log("Tampering detected for " + toolDefinition.id);
                // Requires re-approval even for same version if content changed
                if (!promptUserForApproval(
                    "Tool content changed. Re-approve?", 
                    toolDefinition
                )) {
                    return false;
                }
            }
        } else if (toolDefinition.version < approvedDef.version) {
            log("Warning: Older version presented");
            // Policy decision: allow, warn, or block older versions
        } else { // New version
            if (!promptUserForApproval(
                "New version. Approve?", 
                toolDefinition
            )) {
                return false;
            }
        }
    } else { // First time seeing this tool
        if (!promptUserForApproval("Approve new tool?", toolDefinition)) {
            return false;
        }
    }

    // 3. Store/update approval with new definition hash and version
    storeApproval(
        toolDefinition.id,
        toolDefinition.version,
        Crypto.hash(toolDefinition.content),
        toolDefinition.permissions
    );
    return true;
}
</pre>
                    </div>
                    <div class="image-container">
                        <img src="preventing-tool-poisoning.png" alt="Preventing Tool Poisoning with ETDI">
                    </div>
                </section>

                <section id="cryptographic-identity" class="section">
                    <h2>Cryptographic Identity Verification</h2>
                    <p>ETDI implements robust cryptographic mechanisms to ensure tool authenticity and prevent impersonation attacks.</p>

                    <h3>Core Components</h3>
                    <ul>
                        <li><strong>Digital Signatures:</strong> Tool definitions are signed using provider's private key</li>
                        <li><strong>Certificate-based Identity:</strong> Public key infrastructure for provider verification</li>
                        <li><strong>Request Signing:</strong> All tool invocations include cryptographic signatures</li>
                        <li><strong>Timestamp Validation:</strong> Time-based request validation prevents replay attacks</li>
                    </ul>

                    <h3>Provider Key Infrastructure</h3>
                    <p>Legitimate tool providers must establish cryptographic identity through:</p>
                    <ol>
                        <li><strong>Key Pair Generation:</strong> Providers generate public/private cryptographic key pairs (RSA, ECDSA)</li>
                        <li><strong>Public Key Distribution:</strong> Secure distribution via Host Application, trusted registry, or PKI</li>
                        <li><strong>Private Key Protection:</strong> Secure storage and management of signing keys</li>
                        <li><strong>Certificate Chain Validation:</strong> Optional PKI integration for enhanced trust</li>
                    </ol>

                    <div class="code-block" data-language="JSON">
<pre>
// Example ETDI Tool Definition with Cryptographic Signing
{
    "tool_id": "secure-docs-scanner",
    "version": "1.2.0",
    "name": "Secure Document Scanner",
    "description": "Privacy-preserving document analysis tool",
    "provider": "TrustedSoft Inc.",
    "schema": {
        "type": "object",
        "properties": {
            "document_path": {"type": "string"},
            "analysis_type": {"type": "string", "enum": ["pii", "sentiment", "summary"]}
        }
    },
    "permissions": ["file:read", "network:https"],
    "api_contract_hash": "sha256:abc123...",
    "signature": "base64_encoded_signature_of_entire_definition",
    "public_key": "base64_encoded_public_key",
    "timestamp": "2024-03-14T12:00:00Z",
    "certificate_chain": ["cert1", "cert2", "root_ca"]
}
</pre>
                    </div>

                    <h3>Verification Process</h3>
                    <p>ETDI-enabled MCP Clients perform mandatory verification:</p>
                    <ol>
                        <li><strong>Signature Validation:</strong> Verify definition signature using provider's public key</li>
                        <li><strong>Certificate Chain Verification:</strong> Validate certificate chain to trusted root</li>
                        <li><strong>Timestamp Validation:</strong> Ensure definition is within acceptable time window</li>
                        <li><strong>Revocation Checking:</strong> Verify provider certificates haven't been revoked</li>
                    </ol>

                    <div class="note">
                        <strong>Security Benefit:</strong> Attackers cannot forge valid signatures for tools they don't legitimately own unless they compromise the legitimate provider's private key, making simple impersonation computationally infeasible.
                    </div>
                </section>

                <section id="immutable-definitions" class="section">
                    <h2>Immutable and Versioned Definitions</h2>
                    <p>ETDI enforces immutability of tool definitions through cryptographic versioning and integrity checking, preventing unauthorized post-approval modifications.</p>

                    <h3>Versioning Strategy</h3>
                    <ul>
                        <li><strong>Semantic Versioning:</strong> Tools use semantic versioning (MAJOR.MINOR.PATCH) for clear change indication</li>
                        <li><strong>Content Hashing:</strong> Each version includes cryptographic hash of entire definition</li>
                        <li><strong>API Contract Attestation:</strong> Hash of backend API contract (OpenAPI spec) included in definition</li>
                        <li><strong>Change Tracking:</strong> Comprehensive audit logs of all version changes</li>
                    </ul>

                    <h3>Immutability Enforcement</h3>
                    <p>Once a tool definition is approved and signed, ETDI ensures:</p>
                    <ol>
                        <li><strong>Version Lock:</strong> Specific version numbers cannot be reused with different content</li>
                        <li><strong>Content Integrity:</strong> Any content change requires new version and re-approval</li>
                        <li><strong>Rollback Protection:</strong> Prevents malicious rollback to vulnerable versions</li>
                        <li><strong>Tamper Detection:</strong> Immediate detection of unauthorized modifications</li>
                    </ol>

                    <div class="code-block" data-language="JavaScript">
<pre>
// ETDI Version and Integrity Checking
function validateToolIntegrity(toolDefinition, storedApproval) {
    // Check version consistency
    if (toolDefinition.version !== storedApproval.version) {
        if (isNewerVersion(toolDefinition.version, storedApproval.version)) {
            // New version requires re-approval
            return { status: "NEW_VERSION", requiresApproval: true };
        } else {
            // Older version - policy dependent
            return { status: "OLDER_VERSION", requiresApproval: shouldApproveOlderVersions() };
        }
    }

    // Check content integrity for same version
    const currentHash = Crypto.hash(toolDefinition.content);
    if (currentHash !== storedApproval.contentHash) {
        // Same version but different content = tampering
        return { 
            status: "TAMPERING_DETECTED", 
            requiresApproval: true,
            securityAlert: true 
        };
    }

    // Check API contract integrity if included
    if (toolDefinition.api_contract_hash && 
        toolDefinition.api_contract_hash !== storedApproval.apiContractHash) {
        // Backend API changed without version bump
        return { 
            status: "API_CONTRACT_CHANGED", 
            requiresApproval: true,
            securityAlert: true 
        };
    }

    return { status: "VALID", requiresApproval: false };
}
</pre>
                    </div>
                    <div class="image-container">
                        <img src="preventing-rug-pull.png" alt="Preventing Rug Pulls with ETDI">
                    </div>
                </section>

                <section id="oauth-enhancement" class="section">
                    <h2>OAuth 2.0 Enhancement</h2>
                    <p>ETDI integrates with OAuth 2.0 to provide standardized authorization framework with fine-grained permission management and centralized trust infrastructure.</p>

                    <h3>OAuth Integration Benefits</h3>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🏛️ Standardization</h4>
                            <p>Leverages established OAuth 2.0 protocols for consistent authorization patterns across the ecosystem.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔗 Ecosystem Interoperability</h4>
                            <p>Seamless integration with existing OAuth providers and identity management systems.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🎛️ Fine-grained Access Control</h4>
                            <p>Granular scopes enable precise permission management beyond simple binary approvals.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🏢 Centralized Trust Management</h4>
                            <p>OAuth Identity Providers serve as trusted authorities for tool provider verification.</p>
                        </div>
                    </div>

                    <h3>ETDI-OAuth Architecture</h3>
                    <p>The OAuth-enhanced ETDI architecture introduces several key components:</p>
                    <ul>
                        <li><strong>OAuth Identity Provider (IdP):</strong> Trusted authority that issues tokens and verifies tool provider identities</li>
                        <li><strong>Tool Provider Registration:</strong> Providers register with IdP and receive OAuth client credentials</li>
                        <li><strong>Scope-based Permissions:</strong> Fine-grained OAuth scopes define specific tool capabilities</li>
                        <li><strong>JWT Token Integration:</strong> Signed JSON Web Tokens carry tool identity and permissions</li>
                    </ul>

                    <div class="architecture-diagram">
                        <p>🔄 OAuth-Enhanced ETDI Architecture</p>
                        <p>User → Host App → MCP Client ↔ OAuth IdP ↔ MCP Server → Tool</p>
                    </div>
                    <div class="image-container">
                        <img src="oauth2-integ.png" alt="OAuth 2.0 Integration with ETDI">
                    </div>

                    <h3>Dual Authorization Model</h3>
                    <p>ETDI-OAuth implements a sophisticated dual authorization model:</p>
                    
                    <h4>1. Tool-to-System Authorization</h4>
                    <ul>
                        <li>ETDI verifies tool identity and permissions to MCP client/user</li>
                        <li>OAuth scopes define what system resources tool can access</li>
                        <li>Cryptographic signatures ensure tool authenticity</li>
                    </ul>

                    <h4>2. User-to-Tool Authorization</h4>
                    <ul>
                        <li>Tools verify user/application authorization for their services</li>
                        <li>JWT tokens indicate user entitlements (e.g., subscription level)</li>
                        <li>Dynamic permission validation based on user context</li>
                    </ul>

                    <div class="architecture-diagram">
                        <p>🏗️ Standard MCP Architecture Flow</p>
                        <p>User ↔ Host Application ↔ MCP Client ↔ LLM ↔ MCP Server ↔ Tools</p>
                    </div>
                    <div class="image-container">
                        <img src="OAuth-Enhanced-Tool-Poisoning-Defense.png" alt="OAuth Enhanced Tool Poisoning Defense">
                    </div>

                    <h3>Defense Against Post-Approval Modification (Rug Pulls)</h3>
                    <p>ETDI's immutability and versioning principles provide robust protection against rug pull attacks:</p>

                    <div class="architecture-diagram">
                        <p>🚫 ETDI Rug Pull Prevention</p>
                        <p>Tool Modification → Version Change Detection → Re-approval Required → User Consent</p>
                    </div>
                    <div class="image-container">
                        <img src="OAuth-Enhanced-Rug-Pull-Defense.png" alt="OAuth Enhanced Rug Pull Defense">
                    </div>

                    <h3>Enhanced Trust and Auditability</h3>
                    <p>The integrated ETDI framework provides comprehensive trust and auditability features:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🏛️ Centralized Trust Management</h4>
                            <p>OAuth IdPs serve as centralized authorities for tool provider identity and authorization policy management.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Standardized Permissions</h4>
                            <p>OAuth scopes provide standardized, well-understood permission definitions across the ecosystem.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔄 Revocation Capabilities</h4>
                            <p>IdPs support immediate token and credential revocation for swift response to security compromises.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📝 Comprehensive Audit Trail</h4>
                            <p>Complete logging of all authorization decisions, policy evaluations, and tool interactions for compliance and forensics.</p>
                        </div>
                    </div>

                    <h3>Policy-Based Context-Aware Security</h3>
                    <p>The policy engine layer adds dynamic authorization capabilities that address complex real-world scenarios:</p>
                    <ul>
                        <li><strong>Context-Sensitive Decisions:</strong> Authorization considers time, location, user attributes, data sensitivity, and session history</li>
                        <li><strong>Risk-Based Access Control:</strong> Dynamic risk assessment influences authorization decisions</li>
                        <li><strong>Adaptive Security Posture:</strong> Security controls adapt to changing threat landscape and user behavior patterns</li>
                        <li><strong>Principle of Least Privilege:</strong> Fine-grained policies ensure tools receive minimum necessary permissions</li>
                    </ul>

                    <div class="note">
                        <strong>Security Effectiveness:</strong> By requiring cryptographic proof of identity and integrity for each tool version, making changes explicit and subject to re-approval, and adding contextual policy checks, ETDI significantly raises the operational bar for attackers while providing defense in depth.
                    </div>
                </section>

                <section id="policy-based-control" class="section">
                    <h2>Policy-Based Access Control</h2>
                    <p>ETDI extends beyond static OAuth scopes to implement dynamic, context-aware access control using dedicated policy engines for fine-grained authorization decisions.</p>

                    <h3>Policy Engine Architecture</h3>
                    <p>The policy-based extension integrates specialized Policy Decision Points (PDPs) that evaluate tool actions against dynamic policies considering runtime context:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🧠 Policy Decision Point (PDP)</h4>
                            <p>Centralized engine (OPA, Amazon Verified Permissions) that evaluates authorization requests against defined policies.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📋 Policy Administration Point (PAP)</h4>
                            <p>Management system for creating, updating, and distributing signed policy artifacts.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔍 Context-Aware Evaluation</h4>
                            <p>Dynamic assessment based on time, location, user attributes, data sensitivity, and previous actions.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Real-time Risk Assessment</h4>
                            <p>Continuous evaluation of risk factors and adaptive authorization decisions.</p>
                        </div>
                    </div>

                    <h3>Policy Evaluation Process</h3>
                    <p>When an MCP Client intends to invoke a tool, the following evaluation occurs:</p>

                    <div class="code-block" data-language="JavaScript">
<pre>
// Policy-Based Tool Invocation with Amazon Verified Permissions
function invokeToolWithPolicyCheck(toolId, resourceId, userContext) {
    // 1. Retrieve and verify tool definition via ETDI
    const toolDefinition = MCPClient.getVerifiedToolDefinition(toolId);
    if (!toolDefinition) {
        return AccessDenied("Tool identity/integrity verification failed");
    }

    // 2. Prepare policy evaluation request attributes
    const principal = toolDefinition.identity; // e.g., "ToolVendor::ToolX_v1.2"
    const action = determineToolAction(toolDefinition, resourceId);
    const resource = resourceId; // e.g., "UserDocs::Private::Report.pdf"
    
    // 3. Enrich context with comprehensive attributes
    const context = {
        user: { 
            id: userContext.userId, 
            department: userContext.department,
            clearanceLevel: userContext.securityClearance
        },
        request: { 
            time: currentTime(), 
            purpose: userContext.statedPurpose,
            location: userContext.location,
            deviceTrust: userContext.deviceSecurityPosture
        },
        data: {
            classification: getDataClassification(resourceId),
            sensitivity: getDataSensitivity(resourceId)
        },
        session: {
            previousActions: getSessionHistory(),
            riskScore: calculateRiskScore(userContext)
        }
    };

    // 4. Call Policy Engine for authorization decision
    const policyStoreId = getUserPolicyStore(userContext.userId);
    const authDecision = AmazonVerifiedPermissions.isAuthorized(
        policyStoreId,
        principal,
        action,
        resource,
        context
    );

    // 5. Process authorization result
    if (authDecision.isAllowed()) {
        log("Policy check passed for " + toolId + " on " + resourceId);
        
        // Proceed with tool invocation
        const userAuthToken = HostApp.getUserTokenForTool(toolId);
        const toolResult = MCPServer.invokeTool(
            toolDefinition, 
            resourceId, 
            userAuthToken
        );
        return toolResult;
    } else {
        log("Policy check failed: " + authDecision.errors());
        return AccessDenied("Tool not authorized by policy for this context");
    }
}
</pre>
                    </div>

                    <h3>Policy Request Attributes</h3>
                    <p>The policy engine evaluates requests based on comprehensive attributes:</p>
                    <ul>
                        <li><strong>Principal:</strong> Authenticated identity of the tool (derived from ETDI-OAuth token)</li>
                        <li><strong>Action:</strong> Specific operation the tool intends to perform</li>
                        <li><strong>Resource:</strong> Target resource of the action with classification metadata</li>
                        <li><strong>Context:</strong> Rich contextual information including user attributes, device security posture, time, location, data sensitivity, and session history</li>
                    </ul>
                </section>

                <section id="cedar-integration" class="section">
                    <h2>Cedar Policy Language Integration</h2>
                    <p>ETDI leverages Amazon Verified Permissions with Cedar policy language for expressive, scalable policy definition and enforcement.</p>

                    <h3>Cedar Policy Features</h3>
                    <ul>
                        <li><strong>Expressive Syntax:</strong> Human-readable policy language supporting complex authorization logic</li>
                        <li><strong>Verification-Guided:</strong> Formal verification capabilities ensure policy correctness</li>
                        <li><strong>Hierarchical Policies:</strong> Support for policy inheritance and organization</li>
                        <li><strong>Attribute-Based:</strong> Rich attribute-based access control (ABAC) capabilities</li>
                    </ul>

                    <div class="code-block" data-language="Cedar">
<pre>
// Example Cedar Policies for ETDI Tool Authorization

// Policy 1: Restrict financial data access to certified tools during business hours
permit(
    principal in Group::"CertifiedFinancialTools",
    action == Action::"ReadFile",
    resource in Folder::"FinancialData"
) when {
    context.time.hour >= 9 && context.time.hour <= 17 &&
    context.user.department == "Finance" &&
    principal.certification.includes("SOX-Compliant")
};

// Policy 2: Prevent PII access for tools without privacy certification
forbid(
    principal,
    action == Action::"ProcessDocument",
    resource
) when {
    resource.classification == "PII" &&
    !principal.certifications.includes("Privacy-Shield")
};

// Policy 3: Require elevated approval for high-risk operations
permit(
    principal,
    action == Action::"ModifySystem",
    resource
) when {
    context.approval.level >= "Manager" &&
    context.request.justification != "" &&
    principal.riskScore <= 3
};

// Policy 4: Time-based restrictions for external network access
permit(
    principal,
    action == Action::"NetworkRequest",
    resource
) when {
    context.time.timezone == "UTC" &&
    context.time.hour >= 6 && context.time.hour <= 22 &&
    !resource.destination.includes("suspicious-domains")
};

// Policy 5: Data export restrictions based on user clearance
permit(
    principal in Group::"ExportCapableTools",
    action == Action::"ExportData",
    resource
) when {
    context.user.clearanceLevel >= resource.requiredClearance &&
    context.device.isManaged == true &&
    context.location.isApproved == true
};
</pre>
                    </div>

                    <h3>Policy Lifecycle Management</h3>
                    <p>Cedar policies in ETDI follow rigorous lifecycle management:</p>
                    <ol>
                        <li><strong>Policy Authoring:</strong> Security administrators create policies using Cedar syntax</li>
                        <li><strong>Formal Verification:</strong> Policies undergo verification for correctness and consistency</li>
                        <li><strong>Digital Signing:</strong> Policies are cryptographically signed before distribution</li>
                        <li><strong>Secure Distribution:</strong> Signed policies are distributed to Policy Decision Points</li>
                        <li><strong>Runtime Evaluation:</strong> PDP evaluates requests against current policy set</li>
                        <li><strong>Audit and Monitoring:</strong> All policy decisions are logged for compliance and analysis</li>
                    </ol>

                    <div class="note">
                        <strong>Policy Security:</strong> Policies themselves are treated as signed artifacts within the ETDI framework, ensuring they originate from trusted policy administrators and haven't been tampered with.
                    </div>
                </section>

                <section id="call-stack-verification" class="section">
                    <h2>Call Stack Verification for Tool Chain Security</h2>
                    <p>ETDI implements Call Stack Verification to enforce policies on tool invocation sequences, preventing unauthorized tool chaining and privilege escalation attacks.</p>

                    <h3>Call Stack Security Objectives</h3>
                    <p>The Call Stack Verification system addresses several critical security concerns:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🔗 Unauthorized Tool Chaining</h4>
                            <p>Enforce rules specifying acceptable tool call sequences (e.g., Tool A can call Tool B, but Tool C cannot call Tool D directly).</p>
                        </div>
                        <div class="feature-card">
                            <h4>⬆️ Privilege Escalation Prevention</h4>
                            <p>Prevent scenarios where lower-privilege tools call higher-privilege tools to improperly elevate effective permissions.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔄 Circular Call Dependencies</h4>
                            <p>Detect and prevent call sequences where tools call themselves directly or indirectly, preventing resource exhaustion.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Excessive Call Depth Protection</h4>
                            <p>Limit maximum number of nested tool calls to prevent denial-of-service attacks and stack overflow situations.</p>
                        </div>
                    </div>

                    <h3>Call Stack Policy Framework</h3>
                    <p>The ETDI Call Stack Verifier maintains session state and evaluates tool invocations against CallStackPolicy:</p>

                    <div class="code-block" data-language="JavaScript">
<pre>
// ETDI Call Stack Verification System
class ETDICallStackVerifier {
    constructor() {
        this.activeSessions = new Map();
        this.callStackPolicies = new Map();
        this.maxCallDepth = 10;
        this.rateLimits = new Map();
    }

    verifyToolInvocation(sessionId, callerTool, calleeTool, context) {
        const session = this.getOrCreateSession(sessionId);
        const policy = this.callStackPolicies.get(session.policyId);
        
        // 1. Check maximum call depth
        if (session.callStack.length >= this.maxCallDepth) {
            return {
                allowed: false,
                reason: "EXCESSIVE_CALL_DEPTH",
                maxDepth: this.maxCallDepth
            };
        }

        // 2. Check for circular dependencies
        if (session.callStack.some(call => call.toolId === calleeTool.id)) {
            if (!policy.allowCircularCalls) {
                return {
                    allowed: false,
                    reason: "CIRCULAR_DEPENDENCY_DETECTED",
                    callStack: session.callStack.map(c => c.toolId)
                };
            }
        }

        // 3. Verify caller-callee relationship permissions
        if (!this.isChainAllowed(callerTool, calleeTool, policy)) {
            return {
                allowed: false,
                reason: "UNAUTHORIZED_TOOL_CHAINING",
                caller: callerTool.id,
                callee: calleeTool.id
            };
        }

        // 4. Check privilege escalation
        if (this.detectPrivilegeEscalation(callerTool, calleeTool)) {
            return {
                allowed: false,
                reason: "PRIVILEGE_ESCALATION_ATTEMPT",
                callerPrivileges: callerTool.privileges,
                calleePrivileges: calleeTool.privileges
            };
        }

        // 5. Verify rate limits
        if (!this.checkRateLimit(callerTool.id, calleeTool.id)) {
            return {
                allowed: false,
                reason: "RATE_LIMIT_EXCEEDED"
            };
        }

        // 6. Add to call stack and allow invocation
        session.callStack.push({
            toolId: calleeTool.id,
            caller: callerTool.id,
            timestamp: Date.now(),
            context: context
        });

        return { allowed: true };
    }

    isChainAllowed(callerTool, calleeTool, policy) {
        // Check explicit allow/deny lists
        const chainKey = `${callerTool.id}->${calleeTool.id}`;
        
        if (policy.deniedChains.includes(chainKey)) {
            return false;
        }
        
        if (policy.allowedChains.includes(chainKey)) {
            return true;
        }
        
        // Check group-based permissions
        return policy.defaultChainPolicy === "allow";
    }

    detectPrivilegeEscalation(callerTool, calleeTool) {
        // Compare privilege levels
        const callerLevel = this.getPrivilegeLevel(callerTool.privileges);
        const calleeLevel = this.getPrivilegeLevel(calleeTool.privileges);
        
        // Prevent lower privilege tool calling higher privilege tool
        return callerLevel < calleeLevel;
    }
}
</pre>
                    </div>

                    <h3>Call Stack Policy Definition</h3>
                    <p>CallStackPolicy defines comprehensive rules for tool invocation sequences:</p>

                    <div class="code-block" data-language="JSON">
<pre>
// Example Call Stack Policy Configuration
{
    "policyId": "enterprise-tool-chain-policy",
    "version": "1.0",
    "defaultChainPolicy": "deny",
    "maxCallDepth": 8,
    "allowCircularCalls": false,
    "allowedChains": [
        "data-fetcher->data-analyzer",
        "data-analyzer->report-generator",
        "auth-tool->secure-file-reader",
        "workflow-orchestrator->*"
    ],
    "deniedChains": [
        "external-api-tool->internal-system-tool",
        "guest-tool->admin-tool",
        "*->credential-manager"
    ],
    "privilegeEscalationPolicy": {
        "enabled": true,
        "allowEscalationWithApproval": true,
        "approvalRequired": ["manager", "security-team"]
    },
    "rateLimits": {
        "default": {
            "callsPerMinute": 10,
            "callsPerHour": 100
        },
        "external-api-tool": {
            "callsPerMinute": 3,
            "callsPerHour": 20
        }
    },
    "monitoring": {
        "logAllCalls": true,
        "alertOnViolations": true,
        "alertThresholds": {
            "rateLimitViolations": 5,
            "privilegeEscalationAttempts": 1
        }
    }
}
</pre>
                    </div>

                    <h3>Runtime Monitoring and Enforcement</h3>
                    <p>The Call Stack Verification system provides comprehensive runtime monitoring:</p>
                    <ul>
                        <li><strong>Real-time Validation:</strong> Every tool invocation is validated against current call stack state</li>
                        <li><strong>Violation Logging:</strong> All policy violations are logged with full context</li>
                        <li><strong>Automated Response:</strong> Configurable responses to violations (block, warn, alert)</li>
                        <li><strong>Session Tracking:</strong> Complete call chain tracking per user session</li>
                        <li><strong>Anomaly Detection:</strong> Machine learning-based detection of unusual call patterns</li>
                    </ul>

                    <div class="warning">
                        <strong>Operational Security:</strong> Call Stack Verification adds an essential layer of operational security by closely examining the runtime behavior of linked tools, preventing sophisticated multi-tool attack scenarios.
                    </div>
                </section>

                <section id="security-analysis" class="section">
                    <h2>Comprehensive Security Analysis</h2>
                    <p>The ETDI security model, enhanced with OAuth 2.0 and policy-based access control, provides multi-layered defense against identified threats through synergistic application of core security principles.</p>

                    <h3>Defense Against Tool Impersonation (Tool Poisoning)</h3>
                    <p>ETDI's cryptographic authentication mechanisms effectively counter tool poisoning attacks:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🔐 Cryptographic Authenticity</h4>
                            <p>OAuth tokens from trusted IdPs ensure tool identity is backed by verifiable cryptographic attestation, preventing simple impersonation.</p>
                        </div>
                        <div class="feature-card">
                            <h4>✅ Provider Verification</h4>
                            <p>Clients trust tokens only from specific IdPs and verify the issuer claim, establishing provider authenticity.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔗 Token-Definition Binding</h4>
                            <p>Custom claims link tokens to specific tool definitions, preventing token replay for malicious tools.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📋 Policy Enforcement</h4>
                            <p>Unverified tools are flagged and subjected to strict policies including warnings or complete blocking.</p>
                        </div>
                    </div>

                    <div class="architecture-diagram">
                        <p>🛡️ ETDI Tool Poisoning Defense</p>
                        <p>Malicious Tool → Signature Verification Fails → Access Denied</p>
                        <p>Legitimate Tool → Signature Verified → Policy Check → Access Granted</p>
                    </div>

                    <h3>Defense Against Post-Approval Modification (Rug Pulls)</h3>
                    <p>ETDI's immutability and versioning principles provide robust protection against rug pull attacks:</p>

                    <ul>
                        <li><strong>Immutable Versioning with Re-Approval:</strong> Changes to security-relevant aspects necessitate new version numbers, triggering mandatory user re-approval</li>
                        <li><strong>OAuth Token as Version-Specific Contract:</strong> Tokens are tied to specific tool versions and scopes, making unauthorized modifications detectable</li>
                        <li><strong>Scope Adherence Enforcement:</strong> Client/host enforces that tools operate only within approved OAuth scopes</li>
                        <li><strong>Integrity of Stored Approval:</strong> Client maintains approved versions and permissions, detecting any deviations</li>
                    </ul>

                    <div class="architecture-diagram">
                        <p>🚫 ETDI Rug Pull Prevention</p>
                        <p>Tool Modification → Version Change Detection → Re-approval Required → User Consent</p>
                    </div>

                    <h3>Enhanced Trust and Auditability</h3>
                    <p>The integrated ETDI framework provides comprehensive trust and auditability features:</p>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🏛️ Centralized Trust Management</h4>
                            <p>OAuth IdPs serve as centralized authorities for tool provider identity and authorization policy management.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Standardized Permissions</h4>
                            <p>OAuth scopes provide standardized, well-understood permission definitions across the ecosystem.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔄 Revocation Capabilities</h4>
                            <p>IdPs support immediate token and credential revocation for swift response to security compromises.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📝 Comprehensive Audit Trail</h4>
                            <p>Complete logging of all authorization decisions, policy evaluations, and tool interactions for compliance and forensics.</p>
                        </div>
                    </div>

                    <h3>Policy-Based Context-Aware Security</h3>
                    <p>The policy engine layer adds dynamic authorization capabilities that address complex real-world scenarios:</p>
                    <ul>
                        <li><strong>Context-Sensitive Decisions:</strong> Authorization considers time, location, user attributes, data sensitivity, and session history</li>
                        <li><strong>Risk-Based Access Control:</strong> Dynamic risk assessment influences authorization decisions</li>
                        <li><strong>Adaptive Security Posture:</strong> Security controls adapt to changing threat landscape and user behavior patterns</li>
                        <li><strong>Principle of Least Privilege:</strong> Fine-grained policies ensure tools receive minimum necessary permissions</li>
                    </ul>

                    <div class="note">
                        <strong>Security Effectiveness:</strong> By requiring cryptographic proof of identity and integrity for each tool version, making changes explicit and subject to re-approval, and adding contextual policy checks, ETDI significantly raises the operational bar for attackers while providing defense in depth.
                    </div>
                </section>

                <section id="implementation" class="section">
                    <h2>Implementation Guide</h2>
                    <p>This section provides comprehensive guidance for implementing ETDI in production MCP environments with OAuth enhancement and policy-based access control.</p>

                    <h3>Implementation Phases</h3>
                    <ol>
                        <li><strong>Infrastructure Setup:</strong> Establish cryptographic key management and OAuth infrastructure</li>
                        <li><strong>Tool Definition Migration:</strong> Convert existing tools to ETDI-compliant signed definitions</li>
                        <li><strong>Client Integration:</strong> Update MCP clients to support ETDI verification and OAuth flows</li>
                        <li><strong>Policy Engine Deployment:</strong> Deploy and configure policy decision points</li>
                        <li><strong>Monitoring and Compliance:</strong> Implement comprehensive logging and monitoring systems</li>
                    </ol>

                    <h3>Key Management Setup</h3>
                    <div class="code-block" data-language="JavaScript">
<pre>
// ETDI Key Management Implementation
class ETDIKeyManager {
    constructor(config) {
        this.keyStore = new SecureKeyStore(config.keyStorePath);
        this.certValidator = new CertificateValidator(config.trustedRoots);
        this.revocationChecker = new RevocationChecker(config.crlEndpoints);
    }

    async generateProviderKeys(providerId) {
        // Generate RSA-2048 or ECDSA P-256 key pair
        const keyPair = await crypto.subtle.generateKey(
            {
                name: "RSA-PSS",
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: "SHA-256"
            },
            true,
            ["sign", "verify"]
        );

        // Store private key securely
        await this.keyStore.storePrivateKey(providerId, keyPair.privateKey);
        
        // Export public key for distribution
        const publicKey = await crypto.subtle.exportKey("spki", keyPair.publicKey);
        return {
            providerId,
            publicKey: btoa(String.fromCharCode(...new Uint8Array(publicKey))),
            algorithm: "RSA-PSS-SHA256"
        };
    }

    async signToolDefinition(toolDefinition, providerId) {
        const privateKey = await this.keyStore.getPrivateKey(providerId);
        const dataToSign = JSON.stringify(toolDefinition);
        
        const signature = await crypto.subtle.sign(
            {
                name: "RSA-PSS",
                saltLength: 32
            },
            privateKey,
            new TextEncoder().encode(dataToSign)
        );

        return {
            ...toolDefinition,
            signature: btoa(String.fromCharCode(...new Uint8Array(signature))),
            timestamp: new Date().toISOString(),
            signingAlgorithm: "RSA-PSS-SHA256"
        };
    }

    async verifyToolDefinition(signedDefinition, providerPublicKey) {
        try {
            // Import public key
            const publicKey = await crypto.subtle.importKey(
                "spki",
                new Uint8Array(atob(providerPublicKey).split('').map(c => c.charCodeAt(0))),
                {
                    name: "RSA-PSS",
                    hash: "SHA-256"
                },
                false,
                ["verify"]
            );

            // Extract signature and original data
            const { signature, signingAlgorithm, ...originalDefinition } = signedDefinition;
            const dataToVerify = JSON.stringify(originalDefinition);
            
            // Verify signature
            const isValid = await crypto.subtle.verify(
                {
                    name: "RSA-PSS",
                    saltLength: 32
                },
                publicKey,
                new Uint8Array(atob(signature).split('').map(c => c.charCodeAt(0))),
                new TextEncoder().encode(dataToVerify)
            );

            return { valid: isValid, definition: originalDefinition };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }
}
</pre>
                    </div>

                    <h3>OAuth Integration Implementation</h3>
                    <div class="code-block" data-language="JavaScript">
<pre>
// OAuth-Enhanced ETDI Client Implementation
class OAuthETDIClient {
    constructor(config) {
        this.oauthConfig = config.oauth;
        this.keyManager = new ETDIKeyManager(config.keys);
        this.policyEngine = new PolicyEngine(config.policies);
        this.tokenCache = new Map();
    }

    async authenticateAndAuthorize(toolDefinition, userContext) {
        // 1. Verify tool signature and identity
        const verificationResult = await this.keyManager.verifyToolDefinition(
            toolDefinition,
            await this.getTrustedPublicKey(toolDefinition.provider)
        );

        if (!verificationResult.valid) {
            throw new Error("Tool signature verification failed");
        }

        // 2. Validate OAuth token if present
        if (toolDefinition.oauth_token) {
            const tokenValidation = await this.validateOAuthToken(
                toolDefinition.oauth_token,
                toolDefinition.oauth_config
            );
            
            if (!tokenValidation.valid) {
                throw new Error("OAuth token validation failed");
            }
        }

        // 3. Check policy-based authorization
        const policyDecision = await this.policyEngine.evaluate({
            principal: toolDefinition.tool_id,
            action: userContext.requestedAction,
            resource: userContext.targetResource,
            context: {
                user: userContext.user,
                environment: userContext.environment,
                time: new Date().toISOString()
            }
        });

        if (!policyDecision.allowed) {
            throw new Error(`Policy violation: ${policyDecision.reason}`);
        }

        // 4. Obtain user authorization token if required
        let userToken = null;
        if (toolDefinition.requires_user_auth) {
            userToken = await this.getUserAuthToken(
                toolDefinition.oauth_config,
                userContext.user
            );
        }

        return {
            authorized: true,
            toolDefinition: verificationResult.definition,
            userToken: userToken,
            policyDecision: policyDecision
        };
    }

    async validateOAuthToken(token, oauthConfig) {
        try {
            // Get JWKS from OAuth provider
            const jwks = await this.getJWKS(oauthConfig.jwks_uri);
            
            // Decode and verify JWT
            const decoded = jwt.verify(token, jwks, {
                issuer: oauthConfig.issuer,
                audience: oauthConfig.audience
            });

            // Verify token hasn't been revoked
            const revoked = await this.checkTokenRevocation(token);
            
            return {
                valid: !revoked,
                claims: decoded,
                scopes: decoded.scope ? decoded.scope.split(' ') : []
            };
        } catch (error) {
            return { valid: false, error: error.message };
        }
    }
}
</pre>
                    </div>

                    <h3>Policy Engine Integration</h3>
                    <div class="code-block" data-language="JavaScript">
<pre>
// Amazon Verified Permissions Integration
class AVPPolicyEngine {
    constructor(config) {
        this.avpClient = new VerifiedPermissionsClient({
            region: config.region,
            credentials: config.credentials
        });
        this.policyStoreId = config.policyStoreId;
    }

    async evaluate(authorizationRequest) {
        try {
            const response = await this.avpClient.isAuthorized({
                policyStoreId: this.policyStoreId,
                principal: {
                    entityType: "Tool",
                    entityId: authorizationRequest.principal
                },
                action: {
                    actionType: authorizationRequest.action.type,
                    actionId: authorizationRequest.action.id
                },
                resource: {
                    entityType: "Resource",
                    entityId: authorizationRequest.resource
                },
                context: {
                    contextMap: authorizationRequest.context
                }
            });

            return {
                allowed: response.decision === "ALLOW",
                reason: response.reason,
                determiningPolicies: response.determiningPolicies,
                errors: response.errors || []
            };
        } catch (error) {
            return {
                allowed: false,
                reason: "Policy evaluation error",
                error: error.message
            };
        }
    }

    async createPolicy(policyDefinition) {
        // Create Cedar policy in Amazon Verified Permissions
        return await this.avpClient.createPolicy({
            policyStoreId: this.policyStoreId,
            definition: {
                static: {
                    statement: policyDefinition.cedarStatement
                }
            }
        });
    }
}
</pre>
                    </div>

                    <h3>Deployment Considerations</h3>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🔄 Backward Compatibility</h4>
                            <p>Implement gradual migration strategy allowing coexistence of ETDI and standard MCP tools during transition period.</p>
                        </div>
                        <div class="feature-card">
                            <h4>⚡ Performance Optimization</h4>
                            <p>Implement caching strategies for public keys, policy decisions, and token validation to minimize latency impact.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Monitoring and Alerting</h4>
                            <p>Deploy comprehensive monitoring for signature failures, policy violations, and suspicious activity patterns.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔐 Security Hardening</h4>
                            <p>Secure key storage using Hardware Security Modules (HSMs) or cloud key management services for production deployments.</p>
                        </div>
                    </div>

                    <div class="warning">
                        <strong>Production Readiness:</strong> Ensure proper key rotation procedures, disaster recovery plans, and security incident response procedures are in place before production deployment.
                    </div>
                </section>

                <section id="best-practices" class="section">
                    <h2>Best Practices and Recommendations</h2>
                    <p>Follow these research-backed best practices for secure and effective ETDI implementation in production environments.</p>

                    <h3>Cryptographic Security Best Practices</h3>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>🔑 Strong Cryptography</h4>
                            <ul>
                                <li>Use RSA-2048 minimum, RSA-4096 preferred for signing keys</li>
                                <li>ECDSA P-256 or P-384 for performance-critical applications</li>
                                <li>SHA-256 minimum for hashing, SHA-384 preferred</li>
                                <li>Implement cryptographic agility for algorithm upgrades</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>🔄 Key Management</h4>
                            <ul>
                                <li>Implement automated key rotation (annually minimum)</li>
                                <li>Use Hardware Security Modules (HSMs) for high-value keys</li>
                                <li>Maintain secure key escrow for disaster recovery</li>
                                <li>Implement comprehensive key lifecycle management</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>📜 Certificate Management</h4>
                            <ul>
                                <li>Establish clear certificate authority hierarchy</li>
                                <li>Implement automated certificate renewal</li>
                                <li>Maintain current Certificate Revocation Lists</li>
                                <li>Use OCSP for real-time revocation checking</li>
                            </ul>
                        </div>
                        <div class="feature-card">
                            <h4>🛡️ Signature Verification</h4>
                            <ul>
                                <li>Always verify complete certificate chains</li>
                                <li>Implement timestamp validation with tolerance</li>
                                <li>Cache verification results with TTL limits</li>
                                <li>Log all verification failures for analysis</li>
                            </ul>
                        </div>
                    </div>

                    <h3>OAuth Integration Best Practices</h3>
                    <ul>
                        <li><strong>Token Security:</strong> Use short-lived access tokens (1-hour maximum) with refresh token rotation</li>
                        <li><strong>Scope Design:</strong> Implement fine-grained scopes following principle of least privilege</li>
                        <li><strong>PKCE Implementation:</strong> Always use PKCE for public clients and recommend for confidential clients</li>
                        <li><strong>Token Storage:</strong> Store tokens securely using platform-specific secure storage mechanisms</li>
                        <li><strong>Revocation Support:</strong> Implement immediate token revocation capabilities</li>
                    </ul>

                    <h3>Policy Engine Best Practices</h3>
                    <div class="code-block" data-language="Cedar">
<pre>
// Example Best Practice Cedar Policy Structure
// Policy: Comprehensive data access control with context awareness

permit(
    principal in ToolGroup::"TrustedDataProcessors",
    action in [Action::"ReadFile", Action::"ProcessDocument"],
    resource in DataFolder::"CustomerData"
) when {
    // Time-based restrictions
    context.request.time.hour >= 6 && 
    context.request.time.hour <= 22 &&
    
    // Location restrictions
    context.user.location in Location::"ApprovedOffices" &&
    
    // Device security requirements
    context.device.isManaged == true &&
    context.device.encryptionEnabled == true &&
    
    // User authorization requirements
    context.user.hasValidMFA == true &&
    context.user.trainingCurrent == true &&
    
    // Data classification matching
    principal.dataClassificationLevel >= resource.requiredClearance &&
    
    // Rate limiting
    context.session.requestCount <= 100
};

// Explicit deny for sensitive operations
forbid(
    principal,
    action == Action::"ExportData",
    resource
) when {
    resource.classification == "HIGHLY_CONFIDENTIAL" &&
    !context.user.hasSpecialApproval
};
</pre>
                    </div>

                    <h3>Operational Security Recommendations</h3>
                    <ul>
                        <li><strong>Comprehensive Logging:</strong> Log all authentication, authorization, and policy decisions with sufficient detail for forensic analysis</li>
                        <li><strong>Anomaly Detection:</strong> Implement machine learning-based detection of unusual tool usage patterns</li>
                        <li><strong>Incident Response:</strong> Develop specific incident response procedures for ETDI security events</li>
                        <li><strong>Regular Audits:</strong> Conduct quarterly security audits of tool definitions, policies, and access patterns</li>
                        <li><strong>Performance Monitoring:</strong> Monitor latency impact of verification and policy evaluation processes</li>
                    </ul>

                    <h3>User Experience Optimization</h3>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>📱 Approval Workflows</h4>
                            <p>Design intuitive approval interfaces that clearly explain tool capabilities and risks without overwhelming users with technical details.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔄 Progressive Disclosure</h4>
                            <p>Implement progressive disclosure of tool permissions, showing basic permissions first with option to view detailed technical information.</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Risk Communication</h4>
                            <p>Use visual risk indicators and plain language descriptions to help users make informed security decisions.</p>
                        </div>
                        <div class="feature-card">
                            <h4>⚡ Performance Transparency</h4>
                            <p>Provide clear feedback when security checks are occurring to maintain user confidence in system responsiveness.</p>
                        </div>
                    </div>

                    <h3>Ecosystem Development Guidelines</h3>
                    <ul>
                        <li><strong>Standardization:</strong> Contribute to MCP specification enhancement for ETDI adoption</li>
                        <li><strong>Tool Provider Education:</strong> Develop comprehensive documentation and training for tool providers</li>
                        <li><strong>Client Library Development:</strong> Create reference implementations for major programming languages</li>
                        <li><strong>Testing Framework:</strong> Establish comprehensive testing suites for ETDI compliance verification</li>
                        <li><strong>Community Engagement:</strong> Foster community adoption through open-source implementations and documentation</li>
                    </ul>

                    <div class="note">
                        <strong>Industry Standards:</strong> This implementation follows established security principles from OAuth 2.0, PKI, and policy-based access control domains, ensuring compatibility with existing enterprise security infrastructure.
                    </div>

                    <div class="danger">
                        <strong>Security Critical:</strong> Never store private keys in code or version control. Always use secure key management systems, implement proper access controls, and follow the principle of least privilege throughout your ETDI implementation.
                    </div>
                </section>
            </main>
        </div>
    </div>

    <script>
        // Smooth scrolling for navigation links
        document.querySelectorAll('.security-nav a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // Update active state
                    document.querySelectorAll('.security-nav a').forEach(link => {
                        link.classList.remove('active');
                    });
                    this.classList.add('active');
                }
            });
        });

        // Update active navigation based on scroll position
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.security-nav a[href^="#"]');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= (sectionTop - 200)) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });
    </script>
    <script src="assets/js/main.js"></script>
</body>
</html>